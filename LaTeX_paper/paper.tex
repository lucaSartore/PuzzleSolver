\documentclass{article}

% Required for inserting images
\usepackage{graphicx}

% to insert hiperlinks
\usepackage[colorlinks=true,linkcolor=cyan]{hyperref}

% to have better references
\usepackage[noabbrev]{cleveref}

% to use prefix for references
\usepackage{etoolbox}

% to set the margin of the page
\usepackage[a4paper, total={6.5in, 9in}]{geometry}

% to make indentations
\usepackage{changepage}

% for sub figures
\usepackage{subcaption}

% to allow putting description text to te side of an image
\usepackage{wrapfig}

% rule for reference to fugures
\pretocmd{\thefigure}{F}{}{}

% for the table
\usepackage[table,xcdraw]{xcolor}

% to include svg images
%\usepackage{svg}

% settings for how to indent the page when needed
\newenvironment{indented_section}
  {\adjustwidth{3em}{0pt}}
  {\endadjustwidth}

\title{Use Of Jigsaw Puzzle Solving Algorithms In The Real World}
\author{Luca Sartore}
\date{May 2023}

\begin{document}

\maketitle

\newpage

% make the table of content without the hiperlink color
{
  \hypersetup{linkcolor=black}
  \tableofcontents
}

\newpage

\section{Abstract}
This paper examines the Jigsaw puzzle problem,
which has already been extensively studied in the literature.
Several algorithms with efficient time complexity have been developed
specifically for 'digital' jigsaw puzzles. However, the counterpart:
the 'real world' jigsaw puzzle, has received relatively little attention
in the literature. While some small-scale projects have addressed this issue,
we were unable to find any papers discussing it.

The puzzle problem can be divided into two separate components: the 'Comparator'
whose objective is to determine whether two sides of two pieces fit together,
and the 'Solver' whose objective is to use the information provided
by the comparator to find the best way to fit some pieces together.

Solving the problem in the real world has proven to be more challenging compared
to the digital realm.
This is because all measurements in the real world are noisier than those
in the digital world, making it challenging to obtain accurate data from the Comparator.
The Solver poses its own set of challenges, as it is an example of a
multiobjective optimization problem. Specifically, one objective is to have
the fastest algorithm possible,
while the other objective is to create an algorithm that performs well with
imprecise data. The latter objective is particularly important when solving
real-world puzzles.

In the first half of this paper, a Comparator is developed, and its accuracy
is evaluated.
The data is then used to demonstrate its incompatibility with the current
state-of-the-art algorithm. At this juncture,
two options remain to solve the problem:
either create a superior Comparator or design a
Solver that can operate with noisier data.

The most promising approach to improving the Comparator
involves utilizing machine learning, but this requires a substantial amount of data.
Conversely, creating a better Solver is a less straightforward task.
However, if successful, it could potentially serve as a labeling tool
to generate the dataset needed to train a superior Comparator.

The second part of this paper focuses on developing a
new Solver algorithm specifically designed to work with noisy data.
While the Solver created may not be considered state-of-the-art,
as its time complexity ultimately ends up being worse than the current
best algorithms, it could still play a fundamental role in solving the problem.
As mentioned earlier, it could be employed to solve many small-sized
puzzles and use the results to train a better Comparator.

In conclusion, this paper outlines the additional challenges that the real-world
puzzle problem presents compared to its digital counterpart.
Additionally, it lays the groundwork for a superior machine learning-based Comparator.

\section{Introduction}
\subsection{Classification}
This paper will focus on type 2 puzzles. A type 2 puzzle is a puzzle where the position, and the orientation of each piece is unknown. 
\subsection{Digital vs Real-World Jigsaw Puzzles}

There is  another important distinction between different types of puzzles.
They can be divided into “digital” and “real world” jigsaw puzzles.\label{document:DigitalVSReal}

% figure of digital jigsaw puzzle    
\begin{figure}[h]
    \caption{An example of a “digital” jigsaw  puzzle}\label{fig:figure_digital_puzzle}
    \centering
    \includegraphics[height=0.25\textwidth]{pictures/digital_puzzle.png}
\end{figure}

% figure of real jigsaw puzzle    
\begin{figure}[h]
    \caption{An example of a “real world” jigsaw  puzzle}\label{fig:figure_real_puzzle}
    \includegraphics[height=0.25\textwidth]{pictures/real_puzzle.jpg}
    \centering

\end{figure}

The reason this distinction is important is because,
despite the generic concept of the puzzle not changing,
obtaining accurate matches of a piece's characteristics
is far easier with a digital puzzle,
since there are far less things that can go wrong.


% figure of a mesurement error
\begin{figure}[h]
    \caption{An example of what can go wrong when dealing with the real world}\label{fig:figure_measurement_error}
    \includegraphics[height=0.25\textwidth]{pictures/example_bad_piece.jpg}
    \centering
\end{figure}

\section{Previous Literature}
This section will analyze 3 different algorithms that have been proposed
as a solution of type 2 puzzles. The objective is to understand the
strengths and the weaknesses of each one, to build up some knowledge
that will be useful for the next sections.

\subsection{General Structure Of The Algorithms}

All the algorithms that will be analyzed are composed of 3 sub algorithms:


\begin{indented_section}

    \subsubsection{The Splitter:} This component takes as input one or more images
    containing all the pieces. It then split all the pieces from each other,
    and split each piece into his four sides.\label{document:splitter}

    \subsubsection{The Comparator:} This component compares each side with all the
    others, in order to understand whether they match or not.\newline
    There are two distinct kinds of “Comparator” algorithms:
    The “Binary Comparison” and the “Non Binary Comparison”.
    As the name suggests when comparing two sides with a “Binary Comparison”
    the result can either be 0 (they do not match) or 1 (they match).
    In contrast a “Non Binary Comparison” can give any value between 0 and 1.
    This allows states of uncertainty to be represented.\label{document:comparator}

    \subsubsection{The Solver:} This component  uses the information provided by the
    Comparator~\ref{document:comparator}, and tries to find a solution
    (i.e.\ a position and an orientation for each piece)
    that is the most likely to be correct.\label{document:solver}

\end{indented_section}

\subsection{Solving Jigsaw Puzzles By The Graph Connection Laplacian~\cite{GCL}}
This algorithm falls in the “binary comparison” category~\cref{document:comparator}.
And can be used to understand the strength and weaknesses
of this approach.\newline
The main benefit of this approach is speed,  having a binary comparison allows
some specific optimization, in particular the use of some graph theory techniques.\newline
The  algorithm has a time complexity of ruffly \(O(N^2)\). Which is in line with the theoretical
minimum for jigsaw puzzle solving, according to the study:
“No easy puzzles: Hardness results for jigsaw puzzles~\cite{ON2Claim}”.\newline
The negative aspect might be the accuracy, since by using only two states
(match or not match) some informations are lost, compared to a non binary comparison.
To quantify accuracy the paper used the “neighbors comparison” metric,
which “calculates the percentage of pairs of image patches that are matched correctly”.\newline
\label{document:GCL}

\subsection{A Genetic Algorithm-Based Solver for Very Large Jigsaw Puzzles~\cite{GA}}
This paper applies a genetic algorithm to the jigsaw puzzle problem, with some promising results.\newline
The algorithm seems to have a \(O(N^2)\) time complexity, with time slightly lower than the previous example
(But it is impossible to know for sure which one is faster, given that they didn't specify the hardware used).\newline
The paper has used the same method to evaluate accuracy that the previous one used
(neighbors comparison) so it is easy to compare them.\newline
The algorithm falls in the “Non binary comparison”~\ref{document:comparator};
this should give it an advantage, since it has more data to work with.\newline
Unfortunately this advantage does not compensate for the worst precision
of the algorithm itself, and the accuracy results are equivalent,
if not slightly worse than the previous algorithm.\newline
It is important to keep in mind that for the very nature of genetic algorithms,
it might be possible that the accuracy would have been better if they had allowed
it to run for more generations.\newline
\label{document:GA}

\subsection{Computer Vision Powers Automatic Jigsaw Puzzle Solver~\cite{Abto}}
The solutions~\ref{document:GCL} and~\ref{document:GA} can be considered “state of the art” for digital jigsaw puzzles.
But, as already introduced in section~\ref{document:DigitalVSReal} and better explained in section TODO,
appalling the solution to the real world can be challenging.\newline
This solution is possibly a “state of the art” for real world puzzles.\newline
In reality calling this a “solution” is incorrect,
since all it does is find the best 8 matches and asks the user which one to place.
Making the algorithm not autonomous.\newline
Even ignoring this major detail, making an analysis of this solution has proven to be challenging,
since the article is more of a publicity stunt than an academic paper.
In fact, the code is not open source and the information about the time needed to solve the puzzle is missing.\newline
The article only shows a single puzzle solved, with a 9$\times$6 dimension.\newline
Even with all of these problems this article still is one of the best example of a solution for real world puzzle.

\section{The Objective Of This Paper}
After reading some of the previous literature for this problem, some conclusions could be drawn:
The problem of “digital jigsaw puzzle” has been solved many times, and is already well optimized.\newline
On the other hand, the problem of “real world jigsaw puzzle” has mostly been ignored\newline
by the academic community.\newline

The objective of this paper is to fill this void, by answering the following questions:
\begin{itemize}
    \item Can the current state of the art solutions for digital puzzles be used for real world puzzles, or the unpredictable nature of real world data makes it impossible?
    \item If the algorithms cannot be applied to the real world, what is a possible solution that is more redundant to imprecise data?

  \end{itemize}

\section{The Setup}

To answer these questions, some data to start with,
and an algorithm to analyze the data; in particular the necessary components are:


\subsection{The Puzzle To Solve}

The first step is finding a real world puzzle to solve;
It has been decided to use a classic 500 piece puzzle, and use a printer's
scanner to digitize the pieces.\newline
The puzzle has been scanned in various sub-sizes to allow the testing of different configurations. 
A resolution of 1200 ppi has been used to ensure a sharp and precise image
of the piece, as seen in image~\ref{fig:figure_measurement_error}.
The puzzle has been scanned backward, since the comparator algorithm
that has been used REF does not use colors,
and having an uniform color would make splitting the pieces easier.

\subsection{Splitting The Pieces}
As introduced in section~\ref{document:splitter}, the first step to solve a puzzle
is to split an image composed of many pieces into individual ones.
This is relatively straightforward, and can be done with the following steps:

\begin{itemize}
  \item Apply a threshold and transform an RGB image into a binary mask.
  \item Find all individual Blobs
  (a Blob is just set of connected pixels with the same color) and for each one:

  \begin{itemize}
  \item Calculate the area (the number of pixels the Blob is made of)

  \item Add it to the set of pieces only if his area in within a certain range (to avoid small pieces of dust ending up counted as pieces)

  \end{itemize}

\end{itemize}

\subsection{Splitting The Sides}

The next step following the general template~\ref{document:splitter}
is to split a pieces into
his 4 sides, this could be done with the following steps:

\begin{itemize}

  \item \textbf{Remove the holes from the piece:}\newline
  To do so the program computes the convex hull of the piece~\ref{fig:s_s_ch},
  then calculates the difference between the convex hull and the original image,
  and obtains an image with the “filler areas”~\ref{fig:fig:s_s_og_minus_ch}.
  These filler areas have very different shapes,
  depending on what has generated them (a “hole” or a “knob” in the piece).
  So they can be classified, and added to the original piece only if
  they are generated by a hole, obtaining an image without holes~\ref{fig:s_s_no_holes}.

  \item \textbf{Remove the knobs from he piece}\newline
  To do so the image without holes gets eroded~\ref{fig:s_s_erosion} and then dilated~\ref{fig:s_s_dilatation}.
  This generates an image that resembles the original one, but has no knobs.
  Then the program finds the pixels that are white in the image without holes,
  but not in the image that has been eroded and dilated.
  This generates a set of Blobs~\ref{fig:s_s_no_holes_minus_expansion},
  but again, the shape of the blob is very different depending on what has generated it
  (an “angle” or a “knob”), so they can be classified.
  Then the program removes from the image with no holes all the pixels that are
  close to a Blob generated by a knob, obtaining an image without knobs and holes~\ref{fig:s_s_no_knobs}.
  
  \item \textbf{Find the coordinates of the four corners}\newline
  To find the coordinates of the corners, the program uses a tree steps approximation.
  It initially finds the minimum enclosing rectangle,
  and uses the coordinates of the corners of the rectangle
  as first approximation~\ref{fig:s_s_min_enc_rec}.\newline
  As a second approximation it takes,
  from the white pixels that are close to the first approximation,
  the pixel that has the most black pixels within a certain distance.
  Then it considers only the pixels that are within a certain
  distance of the second approximation, and finds the minimum
  enclosing triangle of sed pixels~\ref{fig:s_s_min_enc_triangle}.\newline
  The corner of the triangle that is closest to the second
  approximation is the third and final approximation
  of the corner of the piece.
  The position of the four corners can be seen in image~\ref{fig:s_s_corners_found}.

  \item \textbf{Split each side using the previously found coordinates.}\newline
	Once the program has found the four coordinates of the corners, to obtain each
  side. An example of a single side can be seen in image~\ref{fig:s_s_a_piece_side}.
\end{itemize}

\begin{figure}
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/original_piece.jpeg}
    \caption{Original binary mask of a piece.}
    \label{fig:s_s_og}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/remove_holes_convex_hull.png}
    \caption{Convex Hull of a piece.}
    \label{fig:s_s_ch}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/remove_holes_filler_areas.png}
    \caption{Difference:~\ref{fig:s_s_ch} \textminus~\ref{fig:s_s_og}.}
    \label{fig:fig:s_s_og_minus_ch}
  \end{subfigure}
  \vspace{1cm}
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/piece_with_no_hole.png}
    \caption{Piece~\ref{fig:s_s_og} with holes removed.}
    \label{fig:s_s_no_holes}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/remove_knobs_erosion.png}
    \caption{Mask~\ref{fig:s_s_no_holes} eroded.}
    \label{fig:s_s_erosion}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/remove_knobs_expansion.png}
    \caption{Mask~\ref{fig:s_s_erosion} dilated.}
    \label{fig:s_s_dilatation}
  \end{subfigure}
  \vspace{1cm}
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/remove_knobs_knob_pixels.png}
    \caption{Difference:~\ref{fig:s_s_no_holes} \textminus~\ref{fig:s_s_erosion}.}
    \label{fig:s_s_no_holes_minus_expansion}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/piece_with_no_knobs.png}
    \caption{Piece~\ref{fig:s_s_no_holes} with knobs removed.}
    \label{fig:s_s_no_knobs}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/find_corners_min_enclosing_rectangle.png}
    \caption{Min enclosing rectangle of~\ref{fig:s_s_no_knobs}.}
    \label{fig:s_s_min_enc_rec}
  \end{subfigure}
\end{figure}
\clearpage
\begin{figure}\ContinuedFloat
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/find_corners_min_enclosing_triangle.png}
    \caption{Min enclosing triangle of the bottom right corner of~\ref{fig:s_s_no_knobs}.}
    \label{fig:s_s_min_enc_triangle}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/corners_found.png}
    \caption{The corners of the piece~\ref{fig:s_s_og}.}
    \label{fig:s_s_corners_found}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.3\textwidth}
    \centering
    \includegraphics[width=\linewidth]{pictures/piece_side.png}
    \caption{One of the sides of the piece~\ref{fig:s_s_og}.}
    \label{fig:s_s_a_piece_side}
  \end{subfigure}
  
  \caption{Steps needed to split an image into his four sides.}
  \label{fig:splitting_sides}
  
\end{figure}

\subsection{Comparing The Sides}\label{document:my_comparator}
The last step needed before it is possible to start working on
a solver algorithm, is to compare the sides that have been
generated by the previous step.\newline
In order to generate a compatibility shore,
the program compute the following steps:

\begin{itemize}
  \item For each side, it considers only the border, and it makes the border thicker.
  \item It puts two sides attached to each other using the coordinates of the corners (In the same way a human would do to test if two pieces fit together).
  \item It calculates the “Or Area”; that is, the number of pixels that belong to the border of one side or the other.
  \item It calculates the “And Area”; that is, the number of pixels that belong to the border of both sides.
  \item It calculates the final shore, which is defined as: \(Shore = \frac{And \space Area}{Or \space Area}\), and goes from 0 to 1.
\end{itemize}


\begin{figure}[htbp]
  \centering
  \begin{minipage}[t]{0.44\textwidth}
    \vspace{3pt} % Ensure alignment of the top of the minipage
    \includegraphics[width=\textwidth]{pictures/side_comparation.png}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.54\textwidth}
    \caption{\newline
    In this image we can see two sides that have been
    compared, one side is drowned in red, the other one in blue.
    In this picture, the “Or Area” is represented by all non
    black pixels; The “And Area” is represented by all the
    purple pixels.}
  \end{minipage}
\end{figure}
\clearpage

\section{Apling Already Existing Algorithms To The Real World}
Now that the setup is completed, it is possible to test the already existing
algorithms with real world puzzles, to see if they can work. For this test,
the fist algorithm~\ref{document:GCL} has been chosen, because the paper is full of detail.
In particular it had some information about the accuracy of the algorithm in
function to the corruption rate, which are essential for this analysis.
\newline \newline
The tests that have been conducted have shown that our comparator algorithm~\ref{document:my_comparator}
and the “Graph Connection Laplacian” solution~\ref{document:GCL} are not compatible with each other.
A proof for this claim follows.

\subsection{Proof}

This section will provide a proof for the incompatibility of
the two algorithms mentioned above.
\newline \newline
The comparison algorithm deceived in section~\ref{document:my_comparator} outputs a compatibility
shore that goes from 0 to 1.\newline
But the algorithm~\ref{document:GCL} takes as input a binary value,
which means that it is necessary to apply a threshold to the input
data to convert them from float to bool.
\subsubsection{Input Data}
To find the optimal threshold a small 16 piece puzzle has been solved.
And the following 4 values have been measured, in function of the threshold:

\begin{itemize}
  \item \textbf{match\%:}\newline
  The probability that 2 random sides match.
  
  \item \textbf{correct combination match\% (or c.c match\%):}\newline
  The probability that 2 sides match given that in the correct puzzle
  solution they actually are close to each other. ideally this should be 1.
  
  \item \textbf{limit match\%:}\newline
  Given that this measure has been taken on a 16 piece puzzle,
  the match\% is highly influenced by the correct piece matching.
  With a bigger puzzle the match\% would be lower.
  Limit match\% is an approximation of what the match\%
  would be in the limit for \(N \rightarrow + \infty\) (where N is the number of pieces).
  This value is obtained by subtracting to match\%
  the probability of choosing randomly the correct side,
  multiplied by the probability that the comparison returns true
  (which is c.c match\%). ideally this should be almost zero.
  \[limit \: math\% = math\% - \frac{c.c. \: mathc\%}{16 \times 4}\]
  
  \item \textbf{corruption rate:}\newline
  Is defined as: \(1-\sqrt{c.c \: match\%}\). ideally this should be 0.

\end{itemize}


% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
  \centering
  \begin{tabular}{
  >{\columncolor[HTML]{FFE599}}c 
  >{\columncolor[HTML]{B6D7A8}}c 
  >{\columncolor[HTML]{9FC5E8}}c 
  >{\columncolor[HTML]{F9CB9C}}c 
  >{\columncolor[HTML]{D9D2E9}}c }
  \cline{1-1}
  \multicolumn{1}{|c|}{\cellcolor[HTML]{F1C232}threshold} &
    \cellcolor[HTML]{6AA84F}match\% &
    \cellcolor[HTML]{3C78D8}c.c match\% &
    \cellcolor[HTML]{E69138}limit match\% &
    \cellcolor[HTML]{8E7CC3}corruption rate \\ \cline{1-1}
  0.000 & 1.000 & 1.000 & 0.984 & 0.000 \\
  0.025 & 0.408 & 1.000 & 0.392 & 0.000 \\
  0.050 & 0.408 & 1.000 & 0.392 & 0.000 \\
  0.075 & 0.408 & 1.000 & 0.392 & 0.000 \\
  0.100 & 0.408 & 1.000 & 0.392 & 0.000 \\
  0.125 & 0.406 & 1.000 & 0.391 & 0.000 \\
  0.150 & 0.400 & 1.000 & 0.385 & 0.000 \\
  0.175 & 0.386 & 1.000 & 0.371 & 0.000 \\
  0.200 & 0.364 & 1.000 & 0.348 & 0.000 \\
  0.225 & 0.335 & 1.000 & 0.319 & 0.000 \\
  0.250 & 0.298 & 1.000 & 0.282 & 0.000 \\
  0.275 & 0.253 & 1.000 & 0.237 & 0.000 \\
  0.300 & 0.201 & 1.000 & 0.185 & 0.000 \\
  0.325 & 0.158 & 1.000 & 0.142 & 0.000 \\
  0.350 & 0.125 & 0.944 & 0.110 & 0.028 \\
  0.375 & 0.100 & 0.944 & 0.085 & 0.028 \\
  0.400 & 0.080 & 0.944 & 0.065 & 0.028 \\
  \cellcolor[HTML]{FF0000}0.425 &
    \cellcolor[HTML]{FF0000}0.054 &
    \cellcolor[HTML]{FF0000}0.889 &
    \cellcolor[HTML]{FF0000}0.040 &
    \cellcolor[HTML]{FF0000}0.057 \\
  0.450 & 0.043 & 0.889 & 0.029 & 0.057 \\
  0.475 & 0.034 & 0.778 & 0.022 & 0.118 \\
  0.500 & 0.025 & 0.778 & 0.013 & 0.118 \\
  0.525 & 0.023 & 0.778 & 0.010 & 0.118 \\
  0.550 & 0.020 & 0.667 & 0.010 & 0.184 \\
  0.575 & 0.019 & 0.667 & 0.009 & 0.184 \\
  0.600 & 0.016 & 0.556 & 0.007 & 0.255 \\
  0.625 & 0.014 & 0.556 & 0.005 & 0.255 \\
  0.650 & 0.014 & 0.556 & 0.005 & 0.255 \\
  0.675 & 0.006 & 0.222 & 0.003 & 0.529 \\
  0.700 & 0.003 & 0.111 & 0.001 & 0.667 \\
  0.725 & 0.001 & 0.000 & 0.001 & 1.000 \\
  0.750 & 0.001 & 0.000 & 0.001 & 1.000 \\
  0.775 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.800 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.825 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.850 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.875 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.900 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.925 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.950 & 0.000 & 0.000 & 0.000 & 1.000 \\
  0.975 & 0.000 & 0.000 & 0.000 & 1.000 \\
  1.000 & 0.000 & 0.000 & 0.000 & 1.000
  \end{tabular}
  \end{table}


\begin{figure}[h]
    \caption{match metrics vs threshold used}\label{fig:match_metrics_vs_threshold_used}
    \centering
    \includegraphics[height=0.5\textwidth]{pictures/match_metrics_vs_threshold_used.png}
\end{figure}

Assuming the algorithm has to solve a 500 piece puzzle, with a limit match\% of 0.04
and a corruption rate of 0.057 (data taken from the line in red);
what would this mean in terms of accuracy of the results?

\subsubsection{Definitions}
This set of definitions are useful to better understand the next section:

\begin{itemize}
  \item \textbf{Connection:}\newline
  When two sides of two different pieces are joined they form a connection.
  A solved puzzle with \(N\) pieces, (assuming it is squared) has around \(2N\) total connections.

  \item \textbf{Possible Combinations:}\newline
  A puzzle with N pieces can be put together in many different ways,
  (even if not all of 	them actually fit together).
  The total number of possible combinations is \(N! \times 4^N\) where
  \(N!\) represent all possible way to combinate the pieces in a particular position, and
  \(4^N\) represents all possible orientations that each piece can have.
  \item \textbf{Possible Correct Combination:}\newline
  Is one of the possible combinations where all the connections are considered a match
  by the comparing algorithm.
  \item \textbf{Actual Correct Combination:}\newline
  An Actual Correct Combination is a Possible Combination that
  is also the correct solution of the original puzzle	
\end{itemize}

\subsubsection{Corruption Rate Analysis}
\begin{figure}[h]
  \caption{Neighbors comparison vs Corruption rate of algorithm \ref{document:GCL}. Image taken from pater \cite{GCL} page 34.}\label{fig:GCL_Corruption_Rate}
  \centering
  \includegraphics[height=0.35\textwidth]{pictures/corruption_rate.png}
\end{figure}

From the graph \ref{fig:GCL_Corruption_Rate}, it can be observed that with a corruption rate of 0.057,
a neighbors comparison value of about 80\%
can be expected. Which means that one in every 5 connections on average will be wrong.
So in a puzzle of 500 pieces (which has approximately 1000 connections),
200 connections will be wrong on average.
It is fair to say that this is not an ideal result.


\subsubsection{Limit Match\% Analysis}
As seen earlier, the limit match percentage is \(4\%\).\newline \newline
Given that in a puzzle of N pieces there are around \(2N \) connections,
the probability of one random combination to be a
possible correct combination is: \(0.054^{2N}\).\newline \newline
The total number of possible combinations are \(N! \times 4^N\),
which means that on average, on a puzzle with \(N\) pieces,
there will be \(0.054^{2N} \times N! \times 4^N \)
possible correct combinations.\newline \newline
For \( N = 500 \) the expected number of possible combinations is around \( 1.5 \times 10^{37} \).
Which makes the chance of finding the actual correct combination basically zero.

\subsubsection{Conclusion}
In this case both the match\% and the corruption rate are bad enough to make a correct reconstruction impossible.
\newline \newline 
To lower the limit match\% is necessary to increase the threshold, but this would increase the corruption rate.
\newline \newline
To lower the corruption rate is necessary to decrease the threshold, but this would increase the limit match\%.
\newline \newline
This means that, regardless of the threshold chosen, our comparison algorithm \ref{document:my_comparator}
can not work with a state of the art solver \ref{document:GCL}.

\subsection{Solutions For The Problem}

There are two way to solve this deadlock:

\subsubsection{Improve The Comparator}
	
Improving the comparator can shortly be done.
Some minor improvements can be made by spending some time tweaking the current algorithm.
But it is clear that, for such a task,
the optimal solution is probably to use machine learning.

\subsubsection{Improving The Solver Algorithm}

Different algorithms have different resilience to corrupted data.
All the major algorithms that have been proposed since now, focus on speed.
It is possible that an algorithm that focuses on accuracy over speed
coud work with our comparator.

\subsubsection{The Path Forward}

Improving the comparator is probably the best long term solution,
but it comes with a problem:\newline
Manually testing if some pieces fit together, then making a scan, and finally label
them to create a dataset would require hundreds if not thousands of hours.\newline
On the other hand improving the solver is not a good solution long term,
given that it will almost certainly have a worst time complexity,
but could have some major short term benefit \newline
In particular it does not require to create a huge dataset,
and could be used to build one.
In Fact it could solve hundreds of small puzzles,
and automatically label the connections using the solution he created.
\newline\newline
Given the two options, the author of this paper has chosen to focus on improving
the solver algorithm. The choice was driven by the lack of the time needed to build a dataset,
And the belief that creating a new algorithm,
for then using that to build a dataset,
would still be faster compared to building a dataset manually.



% referneces page
\clearpage
\begin{thebibliography}{9}

  %Graph Connection Laplacian
  \bibitem{GCL}
    Vahan Huroyan, Gilad   Lerman and Hau-Tieng Wu,
    Solving Jigsaw Puzzles By The Graph Connection Laplacian,
    2020.
    \url{https://arxiv.org/pdf/1811.03188.pdf}.
  % Genetic algorighm
  \bibitem{GA}
    Dror Sholomon, Omid David and Nathan S. Netanyahu,
    A Genetic Algorithm-Based Solver for Very Large Jigsaw Puzzles,
    2013.
    \url{https://openaccess.thecvf.com/content_cvpr_2013/papers/Sholomon_A_Genetic_Algorithm-Based_2013_CVPR_paper.pdf}.
  
    % Claim of best solution O(N^2)
  \bibitem{ON2Claim}
    Michael Brand,
    No easy puzzles: Hardness results for jigsaw puzzles,
    2015.
    \url{https://www.sciencedirect.com/science/article/pii/S0304397515001607}.

    % abtosoftware real world solution
  \bibitem{Abto}
    AbtoSoftware,
    Computer Vision Powers Automatic Jigsaw Puzzle Solver,
    2019.
    \url{https://www.abtosoftware.com/blog/computer-vision-powers-automatic-jigsaw-puzzle-solver}.
  
\end{thebibliography}

\end{document}
